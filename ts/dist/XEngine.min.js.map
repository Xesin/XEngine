{"version":3,"sources":["node_modules/browser-pack/_prelude.js","source/XEngine.js"],"names":[],"mappings":"AAAA,8uBCAA,AACA,2CACA,YACA,GAwPA,gBAvPA,uBACA,MACA,YACA,cACA,yBACA,cACA,kCACA,8BACA,iBACA,sBACA,+BACA,8BACA,4BACA,8BACA,8BACA,YACA,qBACA,eACA,sBACA,kBACA,0BACA,cACA,kBACA,mBACA,uBACA,eACA,gCACA,sBACA,AACA,AACA,AACA,AACA,AACA,wCACA,mBACA,WACA,2IACA,8IACA,qBACA,qCACA,WACA,WACA,WACA,WACA,WACA,WACA,AACA,oCACA,aACA,wBACA,4BACA,eACA,yCACA,mCACA,QACA,cACA,UACA,MACA,YACA,yBACA,yBACA,AACA,WACA,aACA,gBACA,MACA,sBACA,4CACA,AACA,SACA,AACA,cACA,gBACA,MACA,aACA,iEACA,IACA,OACA,MACA,QACA,aACA,eACA,kBACA,SACA,QACA,kBACA,aACA,uDACA,kCACA,kCACA,IASA,YARA,gDACA,kCACA,AACA,QACA,wDACA,oDACA,yBACA,UAEA,cACA,mBACA,kCACA,sBACA,eACA,WACA,gBACA,MACA,oBACA,AACA,oDACA,KACA,mBACA,yDACA,oBACA,2CACA,+BACA,uCACA,mCACA,8DACA,2BACA,4BACA,oCACA,gCACA,AACA,qBACA,wBACA,qDACA,EACA,cACA,MACA,gDACA,qCACA,oBACA,0BACA,kCACA,kCACA,SACA,aACA,wEACA,oBACA,2EACA,uBACA,wBACA,qDACA,2BACA,+BACA,QACA,sBACA,iBACA,aACA,wBACA,mBACA,aACA,CACA,AACA,AACA,eACA,YACA,6BACA,2BACA,SACA,8BACA,kBACA,MACA,QACA,UACA,QACA,YACA,CACA,QACA,SACA,OACA,OACA,OACA,AACA,OACA,iBACA,YACA,mBACA,iCACA,mDACA,yBACA,AACA,AACA,eACA,AACA,AACA,mBACA,AACA,AACA,uBACA,AACA,AACA,AACA,OACA,SACA,UACA,cACA,YACA,eACA,8EACA,wEACA,iFACA,4EACA,GACA,sBACA,4BACA,iCACA,WACA,mBACA,4BACA,kCACA,mBACA,WACA,WACA,YACA,KACA,mBACA,qBACA,gCACA,mBACA,WACA,WACA,YACA,KACA,mBACA,yBACA,2BACA,mBACA,WACA,WACA,YACA,KACA,mBACA,8BACA,gCACA,mBACA,WACA,WACA,YACA,KACA,mBACA,yCACA,EACA,AACA,gBAEA,MACA,YACA,iCACA,qBACA,WACA,QACA,8CACA,WACA,0BACA,wBACA,YACA,AACA,0BACA,AACA,EACA,SACA,CACA,oDACA,AACA,OACA,QACA,oCACA,6CACA,iDACA,qCACA,MACA,WACA,uCACA,sCACA,uDACA,2CACA,6BACA,4BACA,EACA,UACA,MACA,4BACA,AACA,EACA,QACA,MACA,QACA,UACA,OACA,eACA,6BACA,uBACA,AACA,WACA,OACA,MACA,cACA,MACA,YACA,MACA,YACA,4BACA,AACA,UACA,AACA,UACA,mBACA,MACA,YACA,GAsCA,mBArCA,eACA,MACA,MACA,sBACA,AACA,CAWA,gCAVA,AACA,AACA,iCACA,AACA,sBACA,OACA,2BACA,SACA,AACA,SAEA,gBACA,yBACA,0BACA,iBACA,eACA,yBACA,0BACA,iBACA,aACA,wBACA,wBACA,iBACA,WACA,wBAGA,QAFA,KACA,eAEA,iBACA,AACA,gBAEA,MACA,YACA,iCACA,mBACA,CACA,kBACA,WACA,eACA,AACA,CACA,UACA,eACA,wDACA,WACA,cACA,UACA,6BACA,2CACA,AACA,AACA,AACA,aACA,eACA,yCACA,cACA,eACA,MACA,AACA,AACA,eACA,KACA,mBACA,aACA,WACA,aACA,sBACA,MACA,UACA,MACA,YACA,4DACA,WACA,uBACA,YACA,sBACA,AACA,AACA,kBACA,iBACA,yBACA,AACA,WACA,OACA,wCACA,6BACA,0CACA,EACA,wCACA,6BACA,0CACA,EACA,2DACA,yBACA,sCACA,EACA,CAMA,qBALA,mBACA,SACA,AACA,iBACA,MAEA,YACA,uCACA,SACA,AACA,gBACA,WACA,uCACA,kBACA,qBACA,AACA,AACA,gBACA,AACA,UACA,mBACA,MACA,YACA,mDACA,uBACA,CACA,kBACA,cACA,qBACA,wBACA,qCACA,8BACA,qCACA,uCACA,aACA,8CACA,2BACA,cACA,KACA,2CACA,AACA,AACA,6BACA,AACA,0BACA,sBACA,CACA,6CACA,aACA,AACA,yBACA,sDACA,MACA,eACA,AACA,CACA,kBACA,gBACA,OACA,IACA,IACA,IACA,+BACA,qBACA,IACA,GACA,2CACA,AACA,AACA,6BACA,AACA,qBACA,YACA,YACA,YACA,IACA,MACA,GACA,KACA,YACA,qBACA,sBACA,AACA,iCACA,eACA,iBACA,kBACA,iBACA,WACA,iBACA,kBACA,mBACA,kBACA,gBACA,AACA,AACA,AACA,AACA,AACA,iBACA,oDACA,OACA,WACA,eACA,kBACA,SACA,cACA,qBACA,AACA,aACA,yCACA,AACA,GACA,gBACA,gBACA,UACA,AACA,WACA,oBACA,MACA,YACA,IACA,eACA,QACA,oBACA,wBACA,kBACA,sBACA,YAmCA,YAlCA,eACA,MACA,oCACA,uBACA,sBACA,uBACA,QACA,oBACA,MACA,6BACA,mBACA,OACA,gBACA,SACA,CACA,yEACA,aACA,+IACA,mFACA,AACA,AACA,yDACA,WACA,6IACA,qFACA,AACA,AACA,AACA,+CACA,mCACA,kEACA,IACA,AACA,gBAEA,wCACA,gBACA,OACA,aACA,oCACA,mBACA,AACA,gBACA,uBACA,AACA,AACA,KACA,MACA,YACA,WACA,QAoIA,UAnIA,mBACA,sBACA,uBACA,sEACA,uBACA,AACA,iCACA,QACA,aACA,cACA,kBACA,iDACA,gDACA,iCACA,8BACA,mBACA,oBACA,iBACA,yBACA,iBACA,mBACA,OACA,cACA,gCACA,wBACA,QACA,MACA,4BACA,iDACA,IACA,SACA,YACA,qEACA,AACA,AACA,sBACA,iEACA,AACA,qCACA,+BACA,uDACA,uCACA,yCACA,AACA,AACA,0CACA,gBACA,AACA,AACA,QACA,AACA,AACA,qDACA,kBACA,2DACA,WACA,iBACA,sBACA,8BACA,sCACA,AACA,AACA,AACA,kDACA,uBACA,0BACA,8BACA,QACA,CACA,UACA,gDACA,QACA,iBACA,YACA,YACA,sBACA,AACA,oCACA,AACA,2BACA,YACA,iCACA,AACA,EACA,4CACA,WACA,iBACA,YACA,qBACA,aACA,AACA,oCACA,AACA,AACA,gBACA,gCACA,KACA,cACA,aACA,QACA,kBACA,MACA,WACA,mBACA,OACA,EACA,OACA,sBACA,wBACA,iBACA,yBACA,iBACA,mBACA,OACA,oBACA,oBACA,uCACA,mCACA,6BACA,6BACA,+BACA,6CACA,mCACA,sCACA,iBACA,qGACA,gDACA,gCACA,QACA,AACA,gBAEA,MACA,YACA,YACA,wBACA,yBACA,IACA,2BACA,2BACA,KACA,oBACA,iBACA,SACA,mBACA,4BACA,WACA,GACA,wBACA,8KACA,gCACA,EACA,6BACA,aAGA,MADA,IADA,IAGA,AACA,mBACA,2BACA,qCACA,kBACA,uBACA,cACA,OACA,SACA,SACA,iBACA,CACA,aACA,MACA,SACA,GACA,OACA,kBACA,YACA,YACA,EACA,IACA,OACA,kBACA,YACA,YACA,EACA,IACA,YACA,kBACA,YACA,EACA,IACA,kBACA,qBACA,EACA,2CACA,gCACA,IACA,IACA,UACA,YAGA,0BAFA,SACA,8CAEA,KACA,IACA,YACA,YACA,eACA,YACA,UACA,AACA,MACA,IACA,WACA,qBACA,yBACA,aACA,EACA,IACA,aACA,aACA,UACA,KACA,IACA,WACA,YACA,SACA,+BACA,QACA,UACA,KACA,IACA,YACA,uCACA,YACA,SACA,QACA,OACA,iBACA,KACA,SACA,uBACA,OACA,OACA,4BACA,CACA,AACA,yBACA,YACA,oBACA,MACA,YACA,IACA,eACA,YACA,sBACA,2BACA,2BACA,aA+CA,kBA9CA,eACA,MACA,wBACA,0BACA,mCACA,CACA,OACA,OACA,6BAIA,oBAHA,GACA,kBACA,KAEA,cACA,sCACA,OACA,IACA,2BACA,cACA,oBACA,AACA,AACA,+DACA,gBACA,qBACA,2BACA,sBACA,oBACA,AACA,AACA,sBACA,OACA,UACA,iBACA,CACA,kBACA,+BACA,yCACA,sEACA,qCACA,MACA,kBACA,MACA,aACA,AACA,gBAEA,MACA,YACA,GA0CA,kBAzCA,eACA,MACA,YACA,4BACA,2BACA,IACA,SACA,MACA,WACA,SACA,OACA,KACA,8BACA,yBACA,iCACA,AACA,mBACA,4BACA,AACA,cACA,gBACA,4BACA,AACA,AACA,oDACA,qBACA,mDACA,AACA,yBACA,oBACA,2BACA,iCACA,AACA,uBACA,0BACA,gBACA,UACA,8BACA,UACA,AACA,gBAEA,MACA,YACA,GAuFA,cAtFA,iBACA,MACA,oCACA,6BACA,6BAEA,qBADA,oBAEA,uGAKA,mCACA,uEACA,uDACA,6CACA,wGACA,2DACA,iFACA,oBACA,UACA,AACA,sBAdA,+EACA,AACA,AACA,KAYA,SACA,+DACA,oFACA,kCACA,kBACA,yBACA,sBACA,iBACA,AACA,KACA,iBACA,0BACA,kBACA,wBACA,AACA,AACA,aACA,iBACA,AACA,aACA,gBACA,QACA,uBACA,iBACA,oBACA,oBACA,oBACA,kGACA,EACA,cACA,OACA,8BACA,SACA,SACA,AACA,AACA,4BACA,kCACA,wBACA,yBACA,AACA,qDACA,OACA,MACA,AACA,sCACA,iBACA,AACA,0BACA,6BACA,oBACA,6BACA,AACA,wBACA,QACA,AACA,CACA,cACA,YACA,iBACA,IACA,AACA,gBAEA,MACA,YACA,GAyCA,iBAxCA,mBACA,MACA,iBACA,gBACA,kBACA,QACA,OACA,OACA,OACA,aACA,gBACA,KACA,AACA,iBACA,+BACA,4BACA,gBAmBA,iBAlBA,oCACA,WACA,gFACA,GACA,UACA,aACA,sBACA,8BACA,GACA,sBACA,kBACA,AACA,AACA,MACA,sBACA,AACA,mBACA,+BAEA,eACA,MACA,AACA,gBAEA,MACA,YACA,GAoCA,WAnCA,eACA,MACA,YACA,eACA,eACA,OACA,SACA,sBACA,6BACA,AACA,AACA,yCACA,AACA,SACA,SACA,sBACA,6BACA,AACA,AACA,wCACA,AACA,SACA,WACA,aACA,OACA,aACA,aACA,mBACA,mBACA,UACA,eACA,eACA,OACA,AACA,gBAEA,MACA,YACA,GAyCA,iBAxCA,2BACA,MACA,iBACA,gBACA,kBACA,cACA,kBACA,aACA,OACA,OACA,8DACA,QACA,mBACA,oCACA,mBACA,OACA,aACA,oCACA,6BACA,AACA,AACA,sBACA,AACA,WACA,sCACA,8BACA,AACA,AACA,uBACA,AACA,0CACA,kBACA,kBACA,IACA,WACA,kBACA,sCACA,YACA,AACA,gBAEA,MACA,YACA,GAqCA,qBApCA,qBACA,MACA,iBACA,gBACA,eACA,kBACA,yBACA,mBACA,OACA,sDACA,SACA,OACA,MACA,UACA,WACA,OACA,UACA,+BACA,cAcA,iBAbA,mBACA,oBACA,cACA,oCACA,QACA,cACA,AACA,uCACA,YACA,GACA,sBACA,kBACA,IAEA,MACA,AACA,gBAEA,MACA,YACA,GAqDA,YApDA,eACA,MACA,YACA,8BACA,OACA,wCACA,MACA,WACA,8CACA,MACA,qBACA,8CACA,UACA,uBACA,oDACA,MACA,WACA,8CACA,MACA,gBACA,SACA,cACA,kCACA,AACA,AACA,yDACA,yBACA,AACA,AACA,MACA,mBACA,OACA,yCACA,yBACA,WACA,AACA,AACA,sCACA,yCACA,UACA,gCACA,iCACA,gBACA,qBACA,AACA,aACA,aACA,MACA,2CACA,OACA,AACA,gBAEA,MACA,YACA,GAwCA,YAvCA,cACA,MACA,WACA,SACA,2BACA,aAEA,qBADA,SAEA,aACA,2BACA,aAEA,qBADA,SAEA,UACA,oCACA,qBACA,4CACA,AACA,AACA,EACA,WACA,aACA,cACA,WACA,eACA,MACA,8CACA,qDACA,AACA,UACA,WACA,uCACA,2CACA,qCACA,AACA,AACA,EACA,AACA,gBAEA,MACA,YACA,GAmBA,mBAlBA,qBACA,MACA,eACA,cACA,gBACA,uBACA,QACA,WACA,0CACA,gBACA,aACA,AACA,QACA,SACA,yBACA,gBACA,AACA,gBAEA,MACA,YACA,GA8BA,kBA7BA,eACA,iBACA,sBACA,iBACA,iDACA,2CACA,OACA,QACA,iBACA,CACA,gBACA,OACA,kBACA,kBACA,oBACA,UACA,YACA,YACA,WAEA,YADA,eAEA,qBACA,qCACA,WACA,sBACA,sCACA,WACA,AACA,gBAEA,MACA,YACA,GAkCA,kBAjCA,eACA,iBACA,sBACA,iBACA,qDACA,yCACA,2CACA,OACA,QACA,iBACA,CACA,gBACA,OACA,kBACA,kBACA,oBACA,UACA,YACA,YACA,WAEA,YADA,eAEA,uBACA,uCACA,WACA,qBACA,qCACA,WACA,sBACA,sCACA,WACA,AACA,gBAEA,MACA,YACA,kBACA,iBACA,MACA,uBACA,0BACA,QACA,iBACA,gCACA,IACA,oBACA,YACA,kCACA,uCACA,6BACA,eACA,OACA,YACA,UACA,sCACA,uBACA,aACA,AACA,gBACA,yBACA,MACA,YACA,GAuBA,qBAtBA,eACA,MACA,IACA,oBACA,YACA,OACA,wBACA,kBACA,AACA,wBACA,mBACA,wBACA,2BACA,AACA,uBACA,gBACA,OACA,MAEA,+BADA,KAEA,AACA,gBAEA,MACA,YACA,IACA,eACA,cACA,oBACA,2BACA,iBAiCA,eAhCA,6BACA,MACA,iBACA,kBACA,4BACA,UACA,cACA,UACA,iBACA,IACA,AACA,AACA,sCACA,0BACA,SACA,SACA,8CACA,4BACA,6CACA,uDACA,wDACA,AACA,AACA,iDACA,uDACA,+DACA,AACA,oEACA,aACA,SACA,AACA,gBAEA,MACA,YACA,mBACA,iBACA,MACA,uBACA,kBACA,cACA,aACA,iBACA,kCACA,IACA,0BACA,sBACA,CACA,QACA,OACA,OACA,aACA,SACA,AACA,UACA,oBACA,YACA,oCACA,uCACA,6BACA,eACA,OACA,YACA,UACA,cACA,eACA,wCACA,oBACA,kCACA,MACA,iBACA,uCACA,2EACA,AACA,AACA,QACA,AACA,iBACA,0BACA,MACA,YACA,IACA,eACA,cACA,uBACA,wBACA,uBACA,uBACA,wBACA,yBACA,yBACA,yBACA,6BACA,kCACA,8BACA,CAGA,6DAFA,+BACA,OAEA,gCACA,CAEA,+DADA,QAEA,AACA,iBACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,sOACA,AACA,AACA,AACA,AACA,AACA,uHACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,8MACA,4BACA,MACA,YACA,kBACA,SACA,OACA,qBACA,AACA,AACA,WAmIA,YAlIA,sBACA,MACA,yDACA,iCACA,qBACA,wBACA,UACA,iBACA,kBACA,cACA,oBACA,OACA,KACA,wCACA,0BACA,AACA,wBACA,8DACA,4BACA,AACA,wBACA,4BACA,GACA,4BACA,oCACA,iBACA,oBACA,mBACA,oBACA,0CACA,yCAKA,0CAKA,oCACA,qCACA,oCACA,2DACA,qBACA,qCACA,AACA,kBACA,iBACA,yBAbA,0BACA,YACA,AACA,eARA,0BACA,YACA,AACA,KAgBA,eACA,gCACA,sEACA,0EACA,sEACA,gEACA,iBACA,uBACA,2EACA,AACA,AACA,oCACA,+BACA,+EACA,AACA,AACA,iBACA,uBACA,iCACA,gBACA,gBACA,MACA,eACA,AACA,sCACA,cACA,QACA,MACA,eACA,AACA,sCACA,cACA,iBACA,SACA,KACA,0BACA,oCACA,OACA,sBACA,kCACA,OACA,sBACA,qCACA,OACA,sBACA,qCACA,OACA,sBACA,qCACA,OACA,sBACA,6CACA,OACA,sBACA,6CACA,OACA,sBACA,6CACA,OACA,MACA,oCACA,AACA,AACA,QACA,kBACA,qBACA,uBACA,0CACA,yDACA,AACA,AACA,yBACA,+BACA,0CACA,qEACA,AACA,AACA,MACA,AACA,gBAEA,MACA,YACA,IACA,eACA,sBACA,AACA,oBACA,oDACA,AACA,SACA,AACA,AACA,AACA,AACA,AACA,+EACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,qQACA,gDACA,AACA,cACA,AACA,AACA,AACA,AACA,AACA,oFACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,8JACA,qDACA,AACA,cACA,AACA,AACA,AACA,AACA,AACA,oFACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,AACA,oVACA,gCACA,4BACA,MACA,YACA,mCACA,cACA,oEACA,eACA,AACA,wBACA,2BACA,yBACA,MACA,YACA,mCACA,cACA,oEACA,eACA,AACA,wBACA,2BACA,yBACA,MACA,YACA,oCACA,cACA,0DACA,eACA,eACA,MACA,SACA,gBACA,sCACA,0BACA,0CACA,QACA,AACA,yBACA,6BACA,0BACA,MACA,YACA,IACA,eACA,aACA,AACA,qBACA,qBACA,sBACA,qBACA,gCACA,SACA,yBACA,+BACA,gCACA,MACA,YACA,IACA,eACA,GA+IA,iBA9IA,mBACA,MACA,UACA,YACA,2BACA,iBACA,6BACA,4BACA,2BACA,0BACA,uBACA,wBACA,wBACA,eACA,sBACA,iBACA,GACA,cACA,cACA,AACA,AACA,AACA,QACA,SACA,qEACA,iBACA,QACA,AACA,gBAOA,kDACA,2BACA,wCACA,AACA,4BAVA,4DACA,qCACA,kDACA,AACA,AACA,iDAMA,0CACA,8BACA,MACA,SACA,YACA,QACA,gBACA,AACA,yBACA,wCACA,AACA,AACA,4BACA,2DACA,iEACA,KACA,0BACA,mBACA,OACA,iBACA,2BACA,AACA,MACA,eACA,2BACA,8BACA,aACA,AACA,YACA,mBACA,AACA,uCACA,oCACA,kCACA,0CACA,qBACA,mBACA,6BACA,+BACA,mBACA,WACA,eACA,gBACA,YACA,eACA,kBACA,6BACA,mBACA,WACA,eACA,gBACA,YACA,eACA,sBACA,wBACA,mBACA,WACA,eACA,gBACA,YACA,eACA,wBACA,6BACA,mBACA,WACA,eACA,gBACA,YACA,eACA,4DACA,8BACA,0BACA,CACA,QACA,8EACA,oFACA,uGACA,+FACA,4DACA,kBACA,yCACA,iBACA,wBACA,0BACA,uBACA,yBACA,mGACA,iFACA,kGACA,uFACA,4DACA,sBACA,WACA,WACA,WACA,WACA,WACA,AACA,qBACA,EACA,AACA,2BAEA,yBACA","file":"XEngine.min.js","sourcesContent":["(function e(t,n,r){function s(o,u){if(!n[o]){if(!t[o]){var a=typeof require==\"function\"&&require;if(!u&&a)return a(o,!0);if(i)return i(o,!0);var f=new Error(\"Cannot find module '\"+o+\"'\");throw f.code=\"MODULE_NOT_FOUND\",f}var l=n[o]={exports:{}};t[o][0].call(l.exports,function(e){var n=t[o][1][e];return s(n?n:e)},l,l.exports,e,t,n,r)}return n[o].exports}var i=typeof require==\"function\"&&require;for(var o=0;o<r.length;o++)s(r[o]);return s})","\"use strict\";\nvar XEngine;\n(function (XEngine) {\n    class GameObject {\n        constructor(game, posX = 0, posY = 0) {\n            this.game = game;\n            this.parent = game;\n            this.isPendingDestroy = false;\n            this.alive = true;\n            this.alpha = 1.0;\n            this.scale = new XEngine.Vector(1, 1);\n            this.anchor = new XEngine.Vector(0, 0);\n            this.rotation = 0;\n            this.position = new XEngine.Vector(posX, posY);\n            this.onClick = new XEngine.Signal();\n            this.onInputDown = new XEngine.Signal();\n            this.onInputUp = new XEngine.Signal();\n            this.onInputOver = new XEngine.Signal();\n            this.onInputLeft = new XEngine.Signal();\n            this.inputEnabled = false;\n            this.render = true;\n            this.fixedToCamera = false;\n            this.isometric = false;\n            this.isInputDown = false;\n            this.width = 0;\n            this.height = 0;\n            this._prevWidth = 0;\n            this._prevHeight = 0;\n            this._prevPos = { x: 0, y: 0 };\n            this.shader = null;\n            this._vertDataBuffer = new XEngine.DataBuffer32(24 * 4);\n            this._uv = [\n                0.0, 0.0,\n                0.0, 1.0,\n                1.0, 0.0,\n                1.0, 1.0,\n            ];\n            this.gl = this.game.context;\n            let gl = this.gl;\n            let indexDataBuffer = new XEngine.DataBuffer16(2 * 6);\n            this.vertexBuffer = this.game.renderer.resourceManager.createBuffer(gl.ARRAY_BUFFER, this._vertDataBuffer.getByteCapacity(), gl.STREAM_DRAW);\n            this.indexBuffer = this.game.renderer.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, this._vertDataBuffer.getByteCapacity(), gl.STATIC_DRAW);\n            let indexBuffer = indexDataBuffer.uintView;\n            for (let indexA = 0, indexB = 0; indexA < 6; indexA += 6, indexB += 4) {\n                indexBuffer[indexA + 0] = indexB + 0;\n                indexBuffer[indexA + 1] = indexB + 1;\n                indexBuffer[indexA + 2] = indexB + 2;\n                indexBuffer[indexA + 3] = indexB + 1;\n                indexBuffer[indexA + 4] = indexB + 3;\n                indexBuffer[indexA + 5] = indexB + 2;\n            }\n            this.indexBuffer.updateResource(indexBuffer, 0);\n            this.mask = null;\n            this.mvMatrix = mat4.create();\n            mat4.identity(this.mvMatrix);\n            this.pickeable = false;\n            this.downPos = new XEngine.Vector(0, 0);\n            this.posWhenDown = new XEngine.Vector(0, 0);\n            this.color = (0xffffff >> 16) + (0xffffff & 0xff00) + ((0xffffff & 0xff) << 16);\n        }\n        destroy() {\n            this.kill();\n            this.isPendingDestroy = true;\n            if (this.onDestroy !== undefined) {\n                this.onDestroy();\n            }\n        }\n        onDestroy() { return; }\n        _onInitialize() {\n            if (this.shader) {\n                if (!this.shader.compiled) {\n                    this.shader.initializeShader(this.gl);\n                }\n                this._setBuffers();\n            }\n        }\n        setColor(value, a = 1.0) {\n            this.color = value;\n            this.alpha = a;\n            this._setVertices(this.width, this.height, this.color, this._uv);\n        }\n        kill() {\n            this.alive = false;\n        }\n        restore(posX, posY) {\n            this.position.x = posX;\n            this.position.y = posY;\n            this.alive = true;\n        }\n        getWorldMatrix(childMatrix) {\n            this.parent.getWorldMatrix(childMatrix);\n            let translation = [this.position.x, this.position.y, 0.0];\n            let posX = Math.round(-(this.width * this.anchor.x));\n            let posY = Math.round(-(this.height * this.anchor.y));\n            if (this.fixedToCamera) {\n                translation[0] += this.game.camera.position.x;\n                translation[1] += this.game.camera.position.y;\n            }\n            mat4.translate(childMatrix, childMatrix, translation);\n            mat4.rotateZ(childMatrix, childMatrix, this.rotation * XEngine.Mathf.TO_RADIANS);\n            mat4.scale(childMatrix, childMatrix, [this.scale.x, this.scale.y, 1.0]);\n            mat4.translate(childMatrix, childMatrix, [posX, posY, 0.0]);\n            return childMatrix;\n        }\n        getWorldPos() {\n            let parentPos = this.parent.getWorldPos();\n            let x = this.position.x + parentPos.x;\n            let y = this.position.y + parentPos.y;\n            return new XEngine.Vector(x, y);\n        }\n        _beginRender(context) {\n            if (this.shader) {\n                this.shader._beginRender(context);\n            }\n            this.game.renderer.setRenderer(null, null);\n        }\n        _renderToCanvas(context) {\n            this.shader.baseUniforms.pMatrix.value = this.game.camera.pMatrix;\n            this.shader.updateUniforms(context);\n            if (this._prevHeight !== this.height ||\n                this._prevWidth !== this.width ||\n                this._prevPos.x !== this.position.x ||\n                this._prevPos.y !== this.position.y) {\n                this._setVertices(this.width, this.height, this.color, this._uv);\n                this._prevHeight = this.height;\n                this._prevWidth = this.width;\n                this._prevPos.x = this.position.x;\n                this._prevPos.y = this.position.y;\n            }\n            this.vertexBuffer.bind();\n            this.indexBuffer.bind();\n            context.drawElements(context.TRIANGLES, 6, context.UNSIGNED_SHORT, 0);\n        }\n        rendermask(gl) {\n            gl.colorMask(false, false, false, false);\n            gl.stencilFunc(gl.ALWAYS, 1, 1);\n            gl.stencilOp(gl.REPLACE, gl.REPLACE, gl.REPLACE);\n            gl.enable(gl.STENCIL_TEST);\n            if (this.sprite) {\n                let cache_image = this.game.cache.image(this.sprite);\n                this.shader._setTexture(cache_image._texture);\n            }\n            this.shader._beginRender(gl);\n            this.shader.baseUniforms.pMatrix.value = this.game.camera.pMatrix;\n            this.shader.updateUniforms(gl);\n            this._setVertices(this.width, this.height, this.color, this._uv);\n            this.vertexBuffer.bind();\n            this.indexBuffer.bind();\n            gl.drawElements(gl.TRIANGLES, 6, gl.UNSIGNED_SHORT, 0);\n            gl.stencilFunc(gl.EQUAL, 1, 1);\n            gl.stencilOp(gl.ZERO, gl.ZERO, gl.ZERO);\n            gl.colorMask(true, true, true, true);\n        }\n        endRendermask(gl) {\n            gl.disable(gl.STENCIL_TEST);\n            gl.clear(gl.STENCIL_BUFFER_BIT);\n        }\n        _endRender(gl) {\n            if (this.mask != null) {\n                return;\n            }\n        }\n        getBounds() {\n            let width = this.width * this.scale.x;\n            let height = this.height * this.scale.y;\n            let worldPos = this.getWorldPos();\n            let widthAnchor = width * this.anchor.x;\n            let heightAnchor = height * this.anchor.y;\n            let minX = worldPos.x - widthAnchor;\n            let maxX = worldPos.x + width - widthAnchor;\n            let minY = worldPos.y - heightAnchor;\n            let maxY = worldPos.y + height - heightAnchor;\n            return {\n                width: width,\n                height: height,\n                minX: minX,\n                maxX: maxX,\n                minY: minY,\n                maxY: maxY,\n            };\n        }\n        isInsideCamera() {\n            let bounds = this.getBounds();\n            let worldPos = this.getWorldPos();\n            let cameraPos = this.game.camera.position;\n            let viewRect = { width: this.game.width, height: this.game.height };\n            if (bounds.maxX < cameraPos.x) {\n                return false;\n            }\n            if (bounds.maxY < cameraPos.y) {\n                return false;\n            }\n            if (bounds.minX > cameraPos.x + viewRect.width) {\n                return false;\n            }\n            if (bounds.minY > cameraPos.y + viewRect.height) {\n                return false;\n            }\n            return true;\n        }\n        start() { return; }\n        update(deltaTime) { return; }\n        _setBuffers() {\n            let context = this.gl;\n            this.shader.bind(context);\n            this.vertexBuffer.addAttribute(this.shader.vertPosAtt, 2, context.FLOAT, false, 24, 0);\n            this.vertexBuffer.addAttribute(this.shader.vertUvAtt, 2, context.FLOAT, false, 24, 8);\n            this.vertexBuffer.addAttribute(this.shader.vertColAtt, 3, context.UNSIGNED_BYTE, true, 24, 16);\n            this.vertexBuffer.addAttribute(this.shader.vertAlphaAtt, 1, context.FLOAT, false, 24, 20);\n        }\n        _setVertices(width, height, color, uv) {\n            let floatBuffer = this._vertDataBuffer.floatView;\n            let uintBuffer = this._vertDataBuffer.uintView;\n            let index = 0;\n            let pos = new XEngine.Vector(0, 0);\n            this.getWorldMatrix(this.mvMatrix);\n            pos = pos.multiplyMatrix(this.mvMatrix);\n            floatBuffer[index++] = pos.x;\n            floatBuffer[index++] = pos.y;\n            floatBuffer[index++] = uv[0];\n            floatBuffer[index++] = uv[1];\n            uintBuffer[index++] = color;\n            floatBuffer[index++] = this.alpha;\n            pos.setTo(0, this.height);\n            pos = pos.multiplyMatrix(this.mvMatrix);\n            floatBuffer[index++] = pos.x;\n            floatBuffer[index++] = pos.y;\n            floatBuffer[index++] = uv[2];\n            floatBuffer[index++] = uv[3];\n            uintBuffer[index++] = color;\n            floatBuffer[index++] = this.alpha;\n            pos.setTo(this.width, 0);\n            pos = pos.multiplyMatrix(this.mvMatrix);\n            floatBuffer[index++] = pos.x;\n            floatBuffer[index++] = pos.y;\n            floatBuffer[index++] = uv[4];\n            floatBuffer[index++] = uv[5];\n            uintBuffer[index++] = color;\n            floatBuffer[index++] = this.alpha;\n            pos.setTo(this.width, this.height);\n            pos = pos.multiplyMatrix(this.mvMatrix);\n            floatBuffer[index++] = pos.x;\n            floatBuffer[index++] = pos.y;\n            floatBuffer[index++] = uv[6];\n            floatBuffer[index++] = uv[7];\n            uintBuffer[index++] = color;\n            floatBuffer[index++] = this.alpha;\n            this.vertexBuffer.updateResource(floatBuffer, 0);\n        }\n    }\n    XEngine.GameObject = GameObject;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Audio extends XEngine.GameObject {\n        constructor(game, audioName, autoStart, volume) {\n            super(game, 0, 0);\n            this.isLoop = false;\n            this.audio = this.game.cache.audio(audioName).audio;\n            this.persist = false;\n            this.volume = volume || 1;\n            this.onComplete = new XEngine.Signal();\n            this.completed = false;\n            if (autoStart) {\n                this.play(0);\n            }\n        }\n        update() {\n            if (this.gainNode != null) {\n                this.gainNode.gain.value = this.volume;\n            }\n        }\n        play(time) {\n            this.source = this.game.audioContext.createBufferSource();\n            this.source.buffer = this.audio;\n            this.source.connect(this.game.audioContext.destination);\n            this.source.onended = () => {\n                this._complete();\n            };\n            this.gainNode = this.game.audioContext.createGain();\n            this.source.connect(this.gainNode);\n            this.gainNode.connect(this.game.audioContext.destination);\n            this.gainNode.gain.value = this.volume;\n            this.source.loop = this.isLoop;\n            this.source.start(time || 0);\n        }\n        stop(time = 0) {\n            if (this.source) {\n                this.source.stop(time || 0);\n            }\n        }\n        loop(value) {\n            this.isLoop = value;\n        }\n        destroy() {\n            super.destroy();\n            if (this.onComplete) {\n                this.onComplete._destroy();\n                delete this.onComplete;\n            }\n        }\n        kill() {\n            this.alive = false;\n            this.stop();\n        }\n        _complete() {\n            this.stop();\n            if (this.onComplete) {\n                this.onComplete.dispatch();\n            }\n        }\n    }\n    XEngine.Audio = Audio;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class ObjectFactory {\n        constructor(game) {\n            this.game = game;\n        }\n        existing(gameObject, update = true, render = false) {\n            if (update) {\n                this.game.updateQueue.push(gameObject);\n            }\n            if (render) {\n                this.game.renderQueue.push(gameObject);\n            }\n            gameObject.parent = this.game;\n            gameObject._onInitialize();\n            if (gameObject.start !== undefined) {\n                gameObject.start();\n            }\n            return gameObject;\n        }\n        sprite(posX, posY, sprite, frame) {\n            let gameObject = new XEngine.Sprite(this.game, posX, posY, sprite, frame);\n            return this.existing(gameObject, true, true);\n        }\n        image(posX, posY, sprite, frame) {\n            let gameObject = new XEngine.Sprite(this.game, posX, posY, sprite, frame);\n            return this.existing(gameObject, false, true);\n        }\n        audio(audio, autoStart, volume) {\n            let audioObject = new XEngine.Audio(this.game, audio, autoStart, volume);\n            return this.existing(audioObject, true, false);\n        }\n        group(posX, posY) {\n            let x = posX || 0;\n            let y = posY || 0;\n            let gameObject = new XEngine.Group(this.game, x, y);\n            return this.existing(gameObject, true, true);\n        }\n    }\n    XEngine.ObjectFactory = ObjectFactory;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Group extends XEngine.GameObject {\n        constructor(game, posX, posY) {\n            super(game, posX, posY);\n            this.children = new Array();\n        }\n        _beginRender(gl) {\n            return;\n        }\n        update(deltaTime) {\n            this.children.removePending();\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                let gameObject = this.children[i];\n                if (gameObject.alive) {\n                    gameObject.update(deltaTime);\n                    if (XEngine.Sprite.prototype.isPrototypeOf(gameObject)) {\n                        gameObject._updateAnims(this.game.deltaMillis);\n                    }\n                }\n            }\n        }\n        getFirstDead() {\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                let gameObject = this.children[i];\n                if (!gameObject.alive) {\n                    return gameObject;\n                }\n            }\n            return null;\n        }\n        getChildAtIndex(index) {\n            return this.children[index];\n        }\n        childCount() {\n            return this.children.length;\n        }\n        destroy() {\n            this.kill();\n            this.isPendingDestroy = true;\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                let gameObject = this.children[i];\n                if (gameObject.destroy !== undefined) {\n                    gameObject.destroy();\n                    delete this.children[i];\n                }\n            }\n            this.children = [];\n            if (this.onDestroy !== undefined) {\n                this.onDestroy();\n            }\n        }\n        add(gameObject) {\n            if (this.game.updateQueue.indexOf(gameObject) >= 0) {\n                let index = this.game.updateQueue.indexOf(gameObject);\n                this.game.updateQueue.splice(index, 1);\n            }\n            if (this.game.renderQueue.indexOf(gameObject) >= 0) {\n                let index = this.game.renderQueue.indexOf(gameObject);\n                this.game.renderQueue.splice(index, 1);\n            }\n            if (gameObject.parent.constructor === XEngine.Group && gameObject.parent.indexOf(gameObject) >= 0) {\n                let index = gameObject.parent.children.indexOf(gameObject);\n                gameObject.parent.children.splice(index, 1);\n            }\n            this.children.push(gameObject);\n            if (gameObject.start !== undefined) {\n                gameObject.start();\n            }\n            gameObject.parent = this;\n            return gameObject;\n        }\n        setAll(property, value) {\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                this.children[i][property] = value;\n            }\n        }\n        callAll(funct) {\n            for (let i = this.children.length - 1; i >= 0; i--) {\n                if (this.children[i][funct] !== undefined) {\n                    this.children[i][funct]();\n                }\n            }\n        }\n    }\n    XEngine.Group = Group;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Sprite extends XEngine.GameObject {\n        constructor(game, posX, posY, sprite, frame) {\n            super(game, posX, posY);\n            this.sprite = sprite;\n            this.game = game;\n            this.frame = frame || 0;\n            let cache_image = this.game.cache.image(sprite);\n            this.width = cache_image.frameWidth || 10;\n            this.height = cache_image.frameHeight || 10;\n            this.columns = Math.floor(cache_image.image.width / this.width);\n            this.rows = Math.floor(cache_image.image.height / this.height);\n            this.tilled = false;\n            if (this.game.cache.getJson(sprite) !== undefined) {\n                this.json = this.game.cache.getJson(sprite);\n                let frameInfo;\n                if (typeof this.frame === \"string\") {\n                    frameInfo = this.json[this.frame];\n                }\n                else {\n                    frameInfo = this.json.frames[this.frame];\n                }\n                this.width = frameInfo.frame.w;\n                this.height = frameInfo.frame.h;\n            }\n            if (this.columns > 1 || this.rows > 1 || this.json !== undefined) {\n                this.tilled = true;\n            }\n            this.position.setTo(posX, posY);\n            this.shader = this.game.renderer.spriteBatch.shader;\n        }\n        _beginRender(gl) {\n            return;\n        }\n        _renderToCanvas(gl) {\n            if (this.tilled) {\n                let startX = 0;\n                let startY = 0;\n                let endX = 0;\n                let endY = 0;\n                let cache_image = this.game.cache.image(this.sprite);\n                if (this.json) {\n                    let frameInfo;\n                    if (typeof this.frame === \"string\") {\n                        frameInfo = this.json[this.frame];\n                    }\n                    else {\n                        frameInfo = this.json.frames[this.frame];\n                    }\n                    let width = frameInfo.frame.w;\n                    let height = frameInfo.frame.h;\n                    startX = frameInfo.frame.x;\n                    startY = frameInfo.frame.y;\n                    endX = startX + width;\n                    endY = startY + height;\n                }\n                else {\n                    let column = this.frame;\n                    if (column > this.columns - 1) {\n                        column = this.frame % this.columns;\n                    }\n                    let row = Math.floor(this.frame / this.columns);\n                    startX = column * cache_image.frameWidth;\n                    startY = row * cache_image.frameHeight;\n                    endX = startX + cache_image.frameWidth;\n                    endY = startY + cache_image.frameHeight;\n                }\n                let startUvX = startX / cache_image.image.width;\n                let startUvY = startY / cache_image.image.height;\n                let endUvX = endX / cache_image.image.width;\n                let endUvY = endY / cache_image.image.height;\n                this._uv = [\n                    startUvX, startUvY,\n                    startUvX, endUvY,\n                    endUvX, startUvY,\n                    endUvX, endUvY,\n                ];\n            }\n            this.game.renderer.spriteBatch.addSprite(this, this.shader);\n        }\n        reset(x, y) {\n            this.position.x = x;\n            this.position.y = y;\n            this.alive = true;\n            if (this.start !== undefined) {\n                this.start();\n            }\n            if (this.body) {\n                this.body.velocity = new XEngine.Vector(0, 0);\n            }\n        }\n        _updateAnims(deltaMillis) {\n            this.animation._update(deltaMillis);\n        }\n    }\n    XEngine.Sprite = Sprite;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    let AXIS;\n    (function (AXIS) {\n        AXIS[\"NONE\"] = \"none\";\n        AXIS[\"HORIZONTAL\"] = \"horizontal\";\n        AXIS[\"VERTICAL\"] = \"vertical\";\n        AXIS[\"BOTH\"] = \"both\";\n    })(AXIS = XEngine.AXIS || (XEngine.AXIS = {}));\n    class Camera {\n        constructor(game) {\n            this.game = game;\n            this.position = new XEngine.Vector(0, 0);\n            this.followedObject = null;\n            this.axis = XEngine.AXIS.BOTH;\n            this.pMatrix = mat4.create();\n        }\n        followObject(gameObject, offsetLeft, offsetUp) {\n            this.follow = true;\n            this.offsetLeft = offsetLeft || 0;\n            this.offsetUp = offsetUp || 0;\n            this.followedObject = gameObject;\n        }\n        update() {\n            if (this.followedObject != null) {\n                if (this.axis === XEngine.AXIS.BOTH || this.axis === XEngine.AXIS.HORIZONTAL) {\n                    if ((this.followedObject.position.x - this.offsetLeft) - this.game.width / 2 > 0 &&\n                        (this.followedObject.position.x + this.offsetLeft) + this.game.width / 2 < this.game.worldWidth) {\n                        this.position.x = this.followedObject.position.x - this.game.width / 2 - this.offsetLeft;\n                    }\n                }\n                if (this.axis === XEngine.AXIS.BOTH || this.axis === XEngine.AXIS.VERTICAL) {\n                    if ((this.followedObject.position.y - this.offsetUp) - this.game.height / 2 > 0 &&\n                        (this.followedObject.position.y + this.offsetUp) + this.game.height / 2 < this.game.worldHeight) {\n                        this.position.y = this.followedObject.position.y - this.game.height / 2 - this.offsetUp;\n                    }\n                }\n            }\n            let right = this.game.width + this.position.x;\n            let up = this.game.height + this.position.y;\n            mat4.ortho(this.pMatrix, this.position.x, right, up, this.position.y, 0.1, 100);\n        }\n    }\n    XEngine.Camera = Camera;\n})(XEngine || (XEngine = {}));\nArray.prototype.removePending = function () {\n    let i = this.length;\n    while (i--) {\n        if (this[i].isPendingDestroy) {\n            if (this[i].body !== undefined) {\n                this[i].body.destroy();\n            }\n            delete this[i];\n            this.splice(i, 1);\n        }\n    }\n};\nvar XEngine;\n(function (XEngine) {\n    XEngine.version = \"2.0\";\n    class Game {\n        constructor(width, height, idContainer) {\n            this.canvas = document.getElementById(idContainer);\n            if (!this.canvas) {\n                this.canvas = document.body.appendChild(document.createElement(\"canvas\"));\n                this.canvas.id = idContainer;\n            }\n            this.position = new XEngine.Vector(0);\n            this.width = width;\n            this.height = height;\n            this.worldWidth = width;\n            this.worldHeight = height;\n            this.canvas.setAttribute(\"widht\", width.toString());\n            this.canvas.setAttribute(\"height\", height.toString());\n            this.audioContext = new AudioContext();\n            this.frameLimit = 30;\n            this._startTime = 0;\n            this._elapsedTime = 0;\n            this.frameTime = 0;\n            this.previousFrameTime = 0;\n            this.deltaTime = 0;\n            this.deltaMillis = 0;\n            this.pause = false;\n            this.isMobile = false;\n            this.ISO_TILE_WIDTH = 32;\n            this.ISO_TILE_HEIGHT = 32;\n            this.init();\n        }\n        setBackgroundColor(r, g, b, a) {\n            this.renderer.setClearColor(r / 255, g / 255, b / 255, a / 255);\n        }\n        update() {\n            if (window.requestAnimationFrame) {\n                window.requestAnimationFrame(() => { this.update(); });\n            }\n            else {\n                clearTimeout(this.timer);\n                this.timer = setTimeout(() => { this.update(); }, this.frameLimit / 1);\n            }\n            this.elapsedTime = Date.now() - this._startTime;\n            this.frameTime = this.elapsedTime;\n            this.deltaMillis = Math.min(400, (this.frameTime - this.previousFrameTime));\n            this.deltaTime = this.deltaMillis / 1000;\n            if (1 / this.frameLimit > this.deltaTime) {\n                return;\n            }\n            this.previousFrameTime = this.frameTime;\n            if (this.pause) {\n                return;\n            }\n            if (this.state.currentState == null) {\n                return;\n            }\n            if (!this.load.preloading) {\n                this.updateQueue.removePending();\n                for (let i = this.updateQueue.length - 1; i >= 0; i--) {\n                    let gameObject = this.updateQueue[i];\n                    if (gameObject.alive) {\n                        gameObject.update(this.deltaTime);\n                        if (XEngine.Sprite.prototype.isPrototypeOf(gameObject)) {\n                            gameObject._updateAnims(this.deltaMillis);\n                        }\n                    }\n                }\n                this.state.currentState.update(this.deltaTime);\n                this.camera.update();\n                this.renderQueue.removePending();\n                this.renderer.render();\n            }\n        }\n        destroy() {\n            for (let i = this.updateQueue.length - 1; i >= 0; i--) {\n                let gameObject = this.updateQueue[i];\n                if (!gameObject.persist) {\n                    gameObject.destroy();\n                    if (gameObject.body !== undefined) {\n                        gameObject.body.destroy();\n                    }\n                    this.updateQueue.splice(i, 1);\n                }\n                let renderIndex = this.renderQueue.indexOf(gameObject);\n                if (renderIndex !== -1) {\n                    this.renderQueue.splice(renderIndex, 1);\n                }\n            }\n            for (let i = this.renderQueue.length - 1; i >= 0; i--) {\n                let gameObject = this.renderQueue[i];\n                if (!gameObject.persist) {\n                    gameObject.destroy();\n                    if (gameObject.body !== undefined) {\n                        gameObject.body.destroy();\n                    }\n                    this.renderQueue.splice(i, 1);\n                }\n            }\n            delete this.camera;\n            this.camera = new XEngine.Camera(this);\n        }\n        getWorldPos() {\n            return this.position;\n        }\n        getWorldMatrix(childMatrix) {\n            mat4.identity(childMatrix);\n        }\n        getTotalRotation() {\n            return 0;\n        }\n        init() {\n            this._startTime = Date.now();\n            this._elapsedTime = 0;\n            this.frameTime = 0;\n            this.previousFrameTime = 0;\n            this.deltaTime = 0;\n            this.deltaMillis = 0;\n            this.updateQueue = new Array();\n            this.renderQueue = new Array();\n            this.pause = false;\n            this.state = new XEngine.StateManager(this);\n            this.add = new XEngine.ObjectFactory(this);\n            this.cache = new XEngine.Cache(this);\n            this.load = new XEngine.Loader(this);\n            this.camera = new XEngine.Camera(this);\n            this.renderer = new XEngine.Renderer(this, this.canvas);\n            this.context = this.renderer.context;\n            this.scale = new XEngine.ScaleManager(this);\n            this.scale.init();\n            this.isMobile = /Android|webOS|iPhone|iPad|iPod|BlackBerry|IEMobile|Opera Mini/i.test(navigator.userAgent);\n            console.log(\"Game engine \" + XEngine.version + \" arrancado con webgl!!!\");\n            this.update();\n        }\n    }\n    XEngine.Game = Game;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Mathf {\n        static randomRange(min, max) {\n            return min + (Math.random() * (max - min));\n        }\n        static randomIntRange(min, max) {\n            return Math.round(min + Math.random() * (max - min));\n        }\n        static clamp(number, min, max) {\n            return Math.max(Math.min(number, max), min);\n        }\n        static lerp(a, b, t) {\n            t = XEngine.Mathf.clamp(t, 0, 1);\n            return (1 - t) * a + t * b;\n        }\n        static lerpColor(a, b, amount) {\n            let ah = parseInt(a.replace(/#/g, \"\"), 16), ar = ah >> 16, ag = ah >> 8 & 0xff, ab = ah & 0xff, bh = parseInt(b.replace(/#/g, \"\"), 16), br = bh >> 16, bg = bh >> 8 & 0xff, bb = bh & 0xff, rr = ar + amount * (br - ar), rg = ag + amount * (bg - ag), rb = ab + amount * (bb - ab);\n            return \"#\" + ((1 << 24) + (rr << 16) + (rg << 8) + rb | 0).toString(16).slice(1);\n        }\n        static angleBetween(originX, originY, targetX, targetY) {\n            let x = targetX - originX;\n            let y = targetY - originY;\n            return (Math.atan2(y, x));\n        }\n    }\n    Mathf.TO_RADIANS = 0.0174532925199432957;\n    Mathf.TO_DEGREES = 57.2957795130823208767;\n    XEngine.Mathf = Mathf;\n    class Vector {\n        constructor(x, y = x, z = 1.0) {\n            this.zOffset = 0;\n            this.x = x;\n            this.y = y;\n            this.z = z;\n            this.zOffset = 0;\n        }\n        setTo(x, y = x) {\n            this.x = x;\n            this.y = y;\n        }\n        sub(vector) {\n            this.x -= vector.x;\n            this.y -= vector.y;\n            this.z -= vector.z;\n            return this;\n        }\n        add(vector) {\n            this.x += vector.x;\n            this.y += vector.y;\n            this.z += vector.z;\n            return this;\n        }\n        multiply(vector) {\n            this.x *= vector.x;\n            this.y *= vector.y;\n            return this;\n        }\n        multiplyMatrix(matrix) {\n            let x = this.x, y = this.y;\n            let out = new Array(3);\n            this.x = x * matrix[0] + y * matrix[4] + matrix[8] + matrix[12];\n            this.y = x * matrix[1] + y * matrix[5] + matrix[9] + matrix[13];\n            return this;\n        }\n        rotate(angle) {\n            let x = this.x;\n            let y = this.y;\n            this.x = x * Math.cos(angle) - y * Math.sin(angle);\n            this.y = x * Math.sin(angle) + y * Math.cos(angle);\n            return this;\n        }\n        normalize() {\n            let d = this.length();\n            if (d > 0) {\n                this.x = this.x / d;\n                this.y = this.y / d;\n            }\n            return this;\n        }\n        project(vector) {\n            let amt = this.dot(vector) / vector.len2();\n            this.x = amt * vector.x;\n            this.y = amt * vector.y;\n            return this;\n        }\n        scale(x, y = x) {\n            this.x *= x;\n            this.y *= y;\n            return this;\n        }\n        reflect(axis) {\n            let x = this.x;\n            let y = this.y;\n            this.project(axis).scale(2);\n            this.x -= x;\n            this.y -= y;\n            return this;\n        }\n        distance(vector) {\n            let tmp = new XEngine.Vector(this.x, this.y, this.z);\n            tmp.sub(vector);\n            return tmp.length();\n        }\n        len2() {\n            return this.dot(this);\n        }\n        length() {\n            return Math.sqrt(this.len2());\n        }\n        dot(vec) {\n            return this.x * vec.x + this.y * vec.y;\n        }\n    }\n    Vector.Zero = new Vector(0);\n    XEngine.Vector = Vector;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    let Scale;\n    (function (Scale) {\n        Scale[Scale[\"FIT\"] = 0] = \"FIT\";\n        Scale[Scale[\"SHOW_ALL\"] = 1] = \"SHOW_ALL\";\n        Scale[Scale[\"NO_SCALE\"] = 2] = \"NO_SCALE\";\n    })(Scale = XEngine.Scale || (XEngine.Scale = {}));\n    class ScaleManager {\n        constructor(game) {\n            this.game = game;\n            this.scaleType = Scale.NO_SCALE;\n            this.orientation = \"landScape\";\n            this.sourceAspectRatio = 0;\n        }\n        init() {\n            let _this = this;\n            let onWindowsResize = function (event) {\n                _this.onWindowsResize(event);\n            };\n            window.addEventListener(\"resize\", onWindowsResize, true);\n        }\n        updateScale() {\n            if (this.scaleType !== XEngine.Scale.NO_SCALE) {\n                let newWidth = 0;\n                let newHeight = 0;\n                if (this.scaleType === XEngine.Scale.FIT) {\n                    newWidth = window.innerWidth;\n                    newHeight = window.innerHeight;\n                }\n                else {\n                    this.sourceAspectRatio = this.game.width / this.game.height;\n                    newHeight = window.innerHeight;\n                    newWidth = newHeight * this.sourceAspectRatio;\n                    if (newWidth > window.innerWidth) {\n                        newWidth = window.innerWidth;\n                        newHeight = newWidth / this.sourceAspectRatio;\n                    }\n                }\n                newWidth = Math.round(newWidth);\n                newHeight = Math.round(newHeight);\n                this.resizeCanvas(newWidth, newHeight);\n            }\n        }\n        resizeCanvas(newWidth, newHeight) {\n            this.game.canvas.setAttribute(\"width\", newWidth);\n            this.game.canvas.setAttribute(\"height\", newHeight);\n            this.game.renderer.setScale(newWidth / this.game.width, newHeight / this.game.height);\n            this.game.context.viewport(0, 0, newWidth, newHeight);\n        }\n        onWindowsResize(event) {\n            this.updateScale();\n        }\n    }\n    XEngine.ScaleManager = ScaleManager;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class StateManager {\n        constructor(game) {\n            this.game = game;\n            this.states = new Array();\n            this.currentState = null;\n            this.currentStateName = null;\n        }\n        add(stateName, stateClass) {\n            this.states[stateName] = stateClass;\n        }\n        start(stateName) {\n            let _this = this;\n            if (_this.currentState != null) {\n                _this.game.destroy();\n                if (_this.currentState.destroy !== undefined) {\n                    _this.currentState.destroy();\n                }\n                delete _this.currentState;\n                _this.currentState = null;\n            }\n            let state = _this.states[stateName];\n            if (state == null) {\n                console.error(\"no state for name \" + stateName);\n                return;\n            }\n            _this.currentState = new state(_this.game);\n            if (_this.currentState.update === undefined) {\n                _this.currentState.update = function () { return; };\n            }\n            _this.currentState.game = _this.game;\n            _this.currentState.stateName = stateName;\n            if (_this.currentState.preload !== undefined) {\n                _this.currentState.preload();\n            }\n            _this.game.scale.updateScale();\n            _this.game.load._startPreload();\n        }\n        restart() {\n            this.start(this.currentState.stateName);\n        }\n    }\n    XEngine.StateManager = StateManager;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Renderer {\n        constructor(game, canvas) {\n            this.game = game;\n            this.clearColor = { r: 0.0, g: 0.0, b: 0.0, a: 0.0 };\n            this.scale = new XEngine.Vector(1);\n            let options = { stencil: true, antialias: false };\n            this.context = canvas.getContext(\"webgl2\", options);\n            if (!this.context) {\n                alert(\"Imposible inicializar WebGL. Tu navegador puede no soportarlo.\");\n                this.context = null;\n            }\n            else {\n                this.context.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a);\n                this.context.clear(this.context.COLOR_BUFFER_BIT);\n                this.context.blendFunc(this.context.ONE, this.context.ONE_MINUS_SRC_ALPHA);\n                this.context.disable(this.context.DEPTH_TEST);\n                this.context.enable(this.context.BLEND);\n                this.context.viewport(0, 0, Number(this.game.canvas.getAttribute(\"width\")), Number(this.game.canvas.getAttribute(\"height\")));\n                this.resourceManager = new XEngine.ResourceManager(this.context);\n                this.spriteBatch = new XEngine.SpriteBatcher.SpriteBatch(this.game, this.context, this);\n                this.renderer = null;\n                this.sprite = undefined;\n            }\n        }\n        render() {\n            this.context.clear(this.context.COLOR_BUFFER_BIT | this.context.DEPTH_BUFFER_BIT);\n            this.context.viewport(0, 0, this.game.canvas.width, this.game.canvas.height);\n            this.renderLoop(this.game.renderQueue);\n            if (this.renderer) {\n                this.renderer.flush();\n                this.renderer = null;\n                this.sprite = null;\n            }\n        }\n        setRenderer(renderer, sprite) {\n            if (this.renderer !== renderer || this.sprite !== sprite) {\n                if (this.renderer) {\n                    this.renderer.flush();\n                }\n            }\n            if (renderer && renderer.shouldFlush()) {\n                renderer.flush();\n            }\n            this.renderer = renderer;\n            this.sprite = sprite;\n        }\n        setClearColor(r, g, b, a) {\n            this.clearColor.r = r;\n            this.clearColor.g = g;\n            this.clearColor.b = b;\n            this.clearColor.a = a;\n            this.context.clearColor(this.clearColor.r, this.clearColor.g, this.clearColor.b, this.clearColor.a);\n        }\n        renderLoop(arrayObjects) {\n            let _this = this;\n            for (let i = 0; i < arrayObjects.length; i++) {\n                let object = arrayObjects[i];\n                if (!object.render) {\n                    continue;\n                }\n                if (XEngine.Group.prototype.isPrototypeOf(object)) {\n                    object._beginRender(_this.context);\n                    _this.renderLoop(object.children);\n                    object._endRender(_this.context);\n                }\n                else if (!XEngine.Audio.prototype.isPrototypeOf(object)) {\n                    if (!object.alive) {\n                        continue;\n                    }\n                    if (this.game.autoCulling && !object.isInsideCamera()) {\n                        continue;\n                    }\n                    object._beginRender(_this.context);\n                    object._renderToCanvas(_this.context);\n                    if (object.body !== undefined) {\n                        object.body._renderBounds(_this.context);\n                    }\n                    object._endRender(_this.context);\n                }\n            }\n        }\n        setScale(x, y) {\n            this.scale.x = x;\n            this.scale.y = y || x;\n        }\n    }\n    XEngine.Renderer = Renderer;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class AudioLoader {\n        constructor(audioName, audioUrl, loader) {\n            this.audioName = audioName;\n            this.audioUrl = audioUrl;\n            this.completed = false;\n            this.loader = loader;\n        }\n        load() {\n            let _this = this;\n            let newAudio = {\n                audioName: _this.audioName,\n                audio: null,\n                decoded: false,\n            };\n            let request = new XMLHttpRequest();\n            request.open(\"GET\", _this.audioUrl, true);\n            request.responseType = \"arraybuffer\";\n            let handler = function () {\n                let audioRef = _this.loader.game.cache.audios[_this.audioName];\n                if (request.status === 200) {\n                    _this.loader.game.audioContext.decodeAudioData(request.response, function (buffer) {\n                        audioRef.audio = buffer;\n                        audioRef.decoded = true;\n                        _this.completed = true;\n                        _this.loader._notifyCompleted();\n                    }, function () {\n                        _this.completed = true;\n                        _this.loader._notifyCompleted();\n                    });\n                }\n                else {\n                    _this.completed = true;\n                    _this.loader._notifyCompleted();\n                }\n            };\n            request.onload = handler;\n            _this.loader.game.cache.audios[_this.audioName] = newAudio;\n            request.send();\n        }\n    }\n    XEngine.AudioLoader = AudioLoader;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Cache {\n        constructor(game) {\n            this.game = game;\n            this.images = new Array();\n            this.audios = new Array();\n            this.json = new Array();\n        }\n        image(imageName) {\n            if (this.images[imageName] === undefined) {\n                console.error(\"No hay imagen para el nombre: \" + imageName);\n            }\n            else {\n                return this.images[imageName];\n            }\n        }\n        audio(audioName) {\n            if (this.audios[audioName] === undefined) {\n                console.error(\"No hay audio para el nombre: \" + audioName);\n            }\n            else {\n                return this.audios[audioName];\n            }\n        }\n        getJson(jsonName) {\n            return this.json[jsonName];\n        }\n        clearCache() {\n            delete this.images;\n            delete this.audios;\n            delete this.json;\n            this.images = new Array();\n            this.audios = new Array();\n            this.json = new Array();\n        }\n    }\n    XEngine.Cache = Cache;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class ImageLoader {\n        constructor(imageName, imageUrl, loader, frameWidth = 0, frameHeight = 0) {\n            this.imageName = imageName;\n            this.imageUrl = imageUrl;\n            this.completed = false;\n            this.loader = loader;\n            this.frameWidth = frameWidth;\n            this.frameHeight = frameHeight;\n        }\n        load() {\n            let _this = this;\n            let newImage = new XEngine.Texture2D(_this.imageName, _this.frameWidth, _this.frameHeight, 1);\n            let img1 = new Image();\n            let handler = function () {\n                let imageRef = _this.loader.game.cache.images[_this.imageName];\n                imageRef.image = this;\n                _this.completed = true;\n                if (_this.frameWidth === 0) {\n                    imageRef.frameWidth = this.width;\n                    newImage.wrapMode = XEngine.WRAP_MODE.CLAMP;\n                }\n                else {\n                    imageRef.frameWidth = _this.frameWidth;\n                }\n                if (_this.frameHeight === 0) {\n                    imageRef.frameHeight = this.height;\n                    newImage.wrapMode = XEngine.WRAP_MODE.CLAMP;\n                }\n                else {\n                    imageRef.frameHeight = _this.frameHeight;\n                }\n                imageRef.createTexture(_this.loader.game.context);\n                _this.loader._notifyCompleted();\n            };\n            img1.onload = handler;\n            img1.onerror = handler;\n            img1.src = _this.imageUrl;\n            _this.loader.game.cache.images[newImage.imageName] = newImage;\n        }\n    }\n    XEngine.ImageLoader = ImageLoader;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class JsonImageLoader {\n        constructor(imageName, imageUrl, jsonUrl, loader) {\n            this.imageName = imageName;\n            this.imageUrl = imageUrl;\n            this.jsonUrl = jsonUrl;\n            this.completed = false;\n            this.loader = loader;\n            this.frameWidth = 0;\n            this.frameHeight = 0;\n            this.oneCompleted = false;\n            this.loader.image(this.imageName, this.imageUrl);\n        }\n        load() {\n            this.loadJson();\n        }\n        loadJson() {\n            let _this = this;\n            let request = new XMLHttpRequest();\n            request.open(\"GET\", _this.jsonUrl, true);\n            let handler = function () {\n                if (request.status === 200) {\n                    let returnedJson = JSON.parse(request.responseText);\n                    let newJson = returnedJson;\n                    for (let i = 0; i < newJson.frames.length; i++) {\n                        let frame = newJson.frames[i];\n                        newJson[frame.filename] = frame;\n                    }\n                    _this.loader.game.cache.json[_this.imageName] = newJson;\n                }\n                _this.completed = true;\n                _this.loader._notifyCompleted();\n            };\n            request.onload = handler;\n            request.send();\n        }\n    }\n    XEngine.JsonImageLoader = JsonImageLoader;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Loader {\n        constructor(game) {\n            this.game = game;\n            this.pendingLoads = new Array();\n            this.progress = 0;\n            this.preloading = false;\n            this.onCompleteFile = new XEngine.Signal();\n        }\n        image(imageName, imageUrl) {\n            this.pendingLoads.push(new XEngine.ImageLoader(imageName, imageUrl, this));\n        }\n        spriteSheet(imageName, imageUrl, frameWidth, frameHeight) {\n            this.pendingLoads.push(new XEngine.ImageLoader(imageName, imageUrl, this, frameWidth, frameHeight));\n        }\n        jsonSpriteSheet(imageName, imageUrl, jsonUrl) {\n            this.pendingLoads.push(new XEngine.JsonImageLoader(imageName, imageUrl, jsonUrl, this));\n        }\n        audio(audioName, audioUrl) {\n            this.pendingLoads.push(new XEngine.AudioLoader(audioName, audioUrl, this));\n        }\n        _startPreload() {\n            this.preloading = true;\n            if (this.pendingLoads.length === 0) {\n                this._callStart();\n            }\n            else {\n                for (let i = 0; i < this.pendingLoads.length; i++) {\n                    this.pendingLoads[i].load();\n                }\n            }\n        }\n        _notifyCompleted() {\n            let completedTasks = 0;\n            for (let i = 0; i < this.pendingLoads.length; i++) {\n                if (this.pendingLoads[i].completed) {\n                    completedTasks++;\n                }\n            }\n            this.progress = completedTasks / this.pendingLoads.length;\n            this.onCompleteFile.dispatch(this.progress);\n            if (this.progress === 1) {\n                delete this.pendingLoads;\n                this.onCompleteFile._destroy();\n                this.pendingLoads = new Array();\n                this._callStart();\n            }\n        }\n        _callStart() {\n            this.preloading = false;\n            this.game.state.currentState.start();\n        }\n    }\n    XEngine.Loader = Loader;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class Signal {\n        constructor() {\n            this.bindings = new Array();\n        }\n        add(listener, listenerContext) {\n            let newBinding = new XEngine.SignalBinding(this, listener, listenerContext, false);\n            this.bindings.push(newBinding);\n            return newBinding;\n        }\n        addOnce(listener, listenerContext) {\n            let newBinding = new XEngine.SignalBinding(this, listener, listenerContext, true);\n            this.bindings.push(newBinding);\n            return newBinding;\n        }\n        remove(listenerContext) {\n            for (let i = 0; i < this.bindings.length; i++) {\n                if (this.bindings[i].listenerContext === listenerContext) {\n                    this.bindings.splice(i, 1);\n                }\n            }\n        }\n        _destroy() {\n            delete this.bindings;\n            this.bindings = new Array();\n        }\n        dispatch(...eventArguments) {\n            this._cleanup();\n            for (let i = 0; i < this.bindings.length; i++) {\n                this.bindings[i].dispatch.apply(this.bindings[i], arguments);\n            }\n        }\n        _cleanup() {\n            for (let i = this.bindings.length - 1; i >= 0; i--) {\n                if (this.bindings[i] == null || this.bindings[i] === undefined) {\n                    this.bindings.splice(i, 1);\n                }\n            }\n        }\n    }\n    XEngine.Signal = Signal;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class SignalBinding {\n        constructor(signal, listener, listenerContext, isOnce) {\n            this.isOnce = false;\n            this.signal = signal;\n            this.listener = listener;\n            this.listenerContext = listenerContext;\n            this.isOnce = isOnce;\n        }\n        dispatch() {\n            this.listener.apply(this.listenerContext, arguments);\n            if (this.isOnce) {\n                this.detach();\n            }\n        }\n        detach() {\n            this.signal.remove(this.listenerContext);\n        }\n    }\n    XEngine.SignalBinding = SignalBinding;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class DataBuffer16 {\n        constructor(byteSize) {\n            this.wordLength = 0;\n            this.wordCapacity = byteSize / 4;\n            this.buffer = new ArrayBuffer(byteSize);\n            this.intView = new Int16Array(this.buffer);\n            this.uintView = new Uint16Array(this.buffer);\n        }\n        clear() {\n            this.wordLength = 0;\n        }\n        getByteLength() {\n            return this.wordLength * 4;\n        }\n        getByteCapacity() {\n            return this.buffer.byteLength;\n        }\n        allocate(wordSize) {\n            let currentLength = this.wordLength;\n            this.wordLength += wordSize;\n            return currentLength;\n        }\n        getUsedBufferAsInt() {\n            return this.intView.subarray(0, this.wordLength);\n        }\n        getUsedBufferAsUint() {\n            return this.uintView.subarray(0, this.wordLength);\n        }\n    }\n    XEngine.DataBuffer16 = DataBuffer16;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class DataBuffer32 {\n        constructor(byteSize) {\n            this.wordLength = 0;\n            this.wordCapacity = byteSize / 4;\n            this.buffer = new ArrayBuffer(byteSize);\n            this.floatView = new Float32Array(this.buffer);\n            this.intView = new Int32Array(this.buffer);\n            this.uintView = new Uint32Array(this.buffer);\n        }\n        clear() {\n            this.wordLength = 0;\n        }\n        getByteLength() {\n            return this.wordLength * 4;\n        }\n        getByteCapacity() {\n            return this.buffer.byteLength;\n        }\n        allocate(wordSize) {\n            let currentLength = this.wordLength;\n            this.wordLength += wordSize;\n            return currentLength;\n        }\n        getUsedBufferAsFloat() {\n            return this.floatView.subarray(0, this.wordLength);\n        }\n        getUsedBufferAsInt() {\n            return this.intView.subarray(0, this.wordLength);\n        }\n        getUsedBufferAsUint() {\n            return this.uintView.subarray(0, this.wordLength);\n        }\n    }\n    XEngine.DataBuffer32 = DataBuffer32;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class IndexBuffer {\n        constructor(gl, buffer) {\n            this.gl = gl;\n            this.bufferType = gl.ELEMENT_ARRAY_BUFFER;\n            this.buffer = buffer;\n        }\n        static SetDiry() {\n            IndexBuffer.CurrentIndexBuffer = null;\n        }\n        updateResource(bufferData, offset) {\n            let gl = this.gl;\n            IndexBuffer.CurrentIndexBuffer = this;\n            gl.bindBuffer(this.bufferType, this.buffer);\n            gl.bufferSubData(this.bufferType, offset, bufferData);\n        }\n        bind() {\n            let gl = this.gl;\n            let buffer = this.buffer;\n            IndexBuffer.CurrentIndexBuffer = this;\n            gl.bindBuffer(this.bufferType, buffer);\n        }\n    }\n    XEngine.IndexBuffer = IndexBuffer;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class ResourceManager {\n        constructor(gl) {\n            this.gl = gl;\n        }\n        createBuffer(target, initialDataOrSize, usage) {\n            let gl = this.gl;\n            let buffer = gl.createBuffer();\n            gl.bindBuffer(target, buffer);\n            gl.bufferData(target, initialDataOrSize, usage);\n            switch (target) {\n                case gl.ARRAY_BUFFER:\n                    return new XEngine.VertexBuffer(gl, buffer);\n                case gl.ELEMENT_ARRAY_BUFFER:\n                    return new XEngine.IndexBuffer(gl, buffer);\n            }\n        }\n        createShader(shaderClass) {\n            let shader = new shaderClass();\n            shader.initializeShader(this.gl);\n            return shader;\n        }\n    }\n    XEngine.ResourceManager = ResourceManager;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    let WRAP_MODE;\n    (function (WRAP_MODE) {\n        WRAP_MODE[WRAP_MODE[\"CLAMP\"] = 0] = \"CLAMP\";\n        WRAP_MODE[WRAP_MODE[\"WRAP\"] = 1] = \"WRAP\";\n    })(WRAP_MODE = XEngine.WRAP_MODE || (XEngine.WRAP_MODE = {}));\n    class Texture2D {\n        constructor(name, width, height, wrapMode = WRAP_MODE.CLAMP) {\n            this.imageName = name;\n            this.frameWidth = width;\n            this.frameHeight = height;\n            this._texture = null;\n            this.ready = false;\n            this.wrapMode = wrapMode;\n        }\n        createTexture(gl) {\n            if (this.imageName == null) {\n                return;\n            }\n            this._texture = gl.createTexture();\n            const internalFormat = gl.RGBA;\n            const srcFormat = gl.RGBA;\n            const srcType = gl.UNSIGNED_BYTE;\n            gl.bindTexture(gl.TEXTURE_2D, this._texture);\n            if (this.wrapMode === WRAP_MODE.WRAP) {\n                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, srcFormat, srcType, this.image);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.REPEAT);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.REPEAT);\n            }\n            else {\n                gl.texImage2D(gl.TEXTURE_2D, 0, internalFormat, srcFormat, srcType, this.image);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_S, gl.CLAMP_TO_EDGE);\n                gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_WRAP_T, gl.CLAMP_TO_EDGE);\n            }\n            gl.texParameteri(gl.TEXTURE_2D, gl.TEXTURE_MIN_FILTER, gl.LINEAR);\n            this.ready = true;\n        }\n    }\n    XEngine.Texture2D = Texture2D;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class VertexBuffer {\n        constructor(gl, buffer) {\n            this.gl = gl;\n            this.bufferType = gl.ARRAY_BUFFER;\n            this.buffer = buffer;\n            this.attributes = new Array();\n        }\n        static SetDiry() {\n            VertexBuffer.CurrentVertexBuffer = null;\n        }\n        addAttribute(index, size, type, normalized, stride, offset) {\n            this.attributes.push({\n                index: index,\n                size: size,\n                type: type,\n                normalized: normalized,\n                stride: stride,\n                offset: offset,\n            });\n        }\n        updateResource(bufferData, offset) {\n            let gl = this.gl;\n            VertexBuffer.CurrentVertexBuffer = this;\n            gl.bindBuffer(this.bufferType, this.buffer);\n            gl.bufferSubData(this.bufferType, offset, bufferData);\n        }\n        bind() {\n            let gl = this.gl;\n            let buffer = this.buffer;\n            let attributes = this.attributes;\n            let attributesLength = attributes.length;\n            VertexBuffer.CurrentVertexBuffer = this;\n            gl.bindBuffer(gl.ARRAY_BUFFER, buffer);\n            for (let index = 0; index < attributesLength; ++index) {\n                let element = attributes[index];\n                if (element !== undefined && element !== null) {\n                    gl.enableVertexAttribArray(element.index);\n                    gl.vertexAttribPointer(element.index, element.size, element.type, element.normalized, element.stride, element.offset);\n                }\n            }\n        }\n    }\n    XEngine.VertexBuffer = VertexBuffer;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    let Uniforms;\n    (function (Uniforms) {\n        Uniforms[Uniforms[\"FLOAT\"] = 0] = \"FLOAT\";\n        Uniforms[Uniforms[\"INTEGER\"] = 1] = \"INTEGER\";\n        Uniforms[Uniforms[\"MAT2X2\"] = 2] = \"MAT2X2\";\n        Uniforms[Uniforms[\"MAT3X3\"] = 3] = \"MAT3X3\";\n        Uniforms[Uniforms[\"MAT4X4\"] = 4] = \"MAT4X4\";\n        Uniforms[Uniforms[\"VECTOR2\"] = 5] = \"VECTOR2\";\n        Uniforms[Uniforms[\"VECTOR3\"] = 6] = \"VECTOR3\";\n        Uniforms[Uniforms[\"VECTOR4\"] = 7] = \"VECTOR4\";\n        Uniforms[Uniforms[\"SAMPLER\"] = 8] = \"SAMPLER\";\n    })(Uniforms = XEngine.Uniforms || (XEngine.Uniforms = {}));\n    class ShaderCompiler {\n        static compileVertexShader(verxtexString) {\n            verxtexString = verxtexString.replace(\"#XBaseParams\", this.vertexBaseParams.join(\"\\n\"));\n            verxtexString += this.vertexMain.join(\"\\n\");\n            return verxtexString;\n        }\n        static compileFragmentShader(fragmentString) {\n            fragmentString = fragmentString.replace(\"#XBaseParams\", this.fragmentBaseParams.join(\"\\n\"));\n            return fragmentString;\n        }\n    }\n    ShaderCompiler.vertexBaseParams = [\n        \"in vec2 aVertexPosition;\",\n        \"in vec2 vUv;\",\n        \"in vec3 aVertexColor;\",\n        \"in float in_alpha;\",\n        \"uniform mat4 pMatrix;\",\n        \"out highp vec2 uv;\",\n        \"vec4 vertPos;\",\n        \"out lowp vec3 vColor;\",\n        \"out lowp float alpha;\",\n    ];\n    ShaderCompiler.fragmentBaseParams = [\n        \"in lowp vec3 vColor;\",\n        \"in highp vec2 uv;\",\n        \"in float alpha;\",\n        \"out vec4 fragColor;\",\n    ];\n    ShaderCompiler.vertexMain = [\n        \"void main(void) {\",\n        \"vertPos = pMatrix * vec4(aVertexPosition, -1.0, 1.0);\",\n        \"uv = vUv;\",\n        \"vColor = aVertexColor;\",\n        \"alpha = in_alpha;\",\n        \"mainPass();\",\n        \"gl_Position = vertPos;\",\n        \"}\",\n    ];\n    XEngine.ShaderCompiler = ShaderCompiler;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    XEngine.ShaderUniforms = {\n        pMatrix: {\n            value: null,\n            type: XEngine.Uniforms.MAT4X4,\n        },\n    };\n    class Shader {\n        constructor(vertexCode, fragmentCode, uniforms = {}) {\n            this.uniforms = uniforms;\n            this.baseUniforms = JSON.parse(JSON.stringify(XEngine.ShaderUniforms));\n            this.vertColAtt = null;\n            this.vertColAtt = null;\n            this.shaderProgram = null;\n            this.compiled = false;\n            this.vertexCode = vertexCode;\n            this.fragmentCode = fragmentCode;\n        }\n        initializeShader(gl) {\n            let vertString = \"\";\n            let fragmentString = \"\";\n            for (let i = 0; i < this.vertexCode.length; i++) {\n                vertString += this.vertexCode[i] + \"\\n\";\n            }\n            vertString = XEngine.ShaderCompiler.compileVertexShader(vertString);\n            for (let j = 0; j < this.fragmentCode.length; j++) {\n                fragmentString += this.fragmentCode[j] + \"\\n\";\n            }\n            fragmentString = XEngine.ShaderCompiler.compileFragmentShader(fragmentString);\n            let vertexShader;\n            let fragmentShader;\n            fragmentShader = gl.createShader(gl.FRAGMENT_SHADER);\n            vertexShader = gl.createShader(gl.VERTEX_SHADER);\n            gl.shaderSource(vertexShader, vertString);\n            gl.compileShader(vertexShader);\n            gl.shaderSource(fragmentShader, fragmentString);\n            gl.compileShader(fragmentShader);\n            if (!gl.getShaderParameter(vertexShader, gl.COMPILE_STATUS)) {\n                alert(gl.getShaderInfoLog(vertexShader));\n                this.compiled = true;\n                return null;\n            }\n            if (!gl.getShaderParameter(fragmentShader, gl.COMPILE_STATUS)) {\n                alert(gl.getShaderInfoLog(fragmentShader));\n                this.compiled = true;\n                return null;\n            }\n            this.shaderProgram = gl.createProgram();\n            gl.attachShader(this.shaderProgram, vertexShader);\n            gl.attachShader(this.shaderProgram, fragmentShader);\n            gl.linkProgram(this.shaderProgram);\n            if (!gl.getProgramParameter(this.shaderProgram, gl.LINK_STATUS)) {\n                alert(\"Could not initialise shaders\");\n                this.compiled = true;\n            }\n            this.compiled = true;\n            this.setUniforms(gl);\n        }\n        setUniforms(gl) {\n            gl.useProgram(this.shaderProgram);\n            this.vertPosAtt = gl.getAttribLocation(this.shaderProgram, \"aVertexPosition\");\n            this.vertColAtt = gl.getAttribLocation(this.shaderProgram, \"aVertexColor\");\n            this.vertUvAtt = gl.getAttribLocation(this.shaderProgram, \"vUv\");\n            this.vertAlphaAtt = gl.getAttribLocation(this.shaderProgram, \"in_alpha\");\n            for (let property in this.uniforms) {\n                if (this.uniforms.hasOwnProperty(property)) {\n                    this.uniforms[property].gpuPosition = gl.getUniformLocation(this.shaderProgram, property);\n                }\n            }\n            for (let property in this.baseUniforms) {\n                if (this.baseUniforms.hasOwnProperty(property)) {\n                    this.baseUniforms[property].gpuPosition = gl.getUniformLocation(this.shaderProgram, property);\n                }\n            }\n        }\n        getAttribLocation(gl, attr) {\n            return gl.getAttribLocation(this.shaderProgram, attr);\n        }\n        _beginRender(gl) {\n            if (!this.compiled) {\n                this.initializeShader(gl);\n            }\n            gl.useProgram(this.shaderProgram);\n        }\n        bind(gl) {\n            if (!this.compiled) {\n                this.initializeShader(gl);\n            }\n            gl.useProgram(this.shaderProgram);\n        }\n        _setUniform(uniform, gl) {\n            let valueType = uniform.type;\n            switch (valueType) {\n                case XEngine.Uniforms.INTEGER:\n                    gl.uniform1i(uniform.gpuPosition, uniform.value);\n                    break;\n                case XEngine.Uniforms.FLOAT:\n                    gl.uniform1f(uniform.gpuPosition, uniform.value);\n                    break;\n                case XEngine.Uniforms.VECTOR2:\n                    gl.uniform2fv(uniform.gpuPosition, uniform.value);\n                    break;\n                case XEngine.Uniforms.VECTOR3:\n                    gl.uniform3fv(uniform.gpuPosition, uniform.value);\n                    break;\n                case XEngine.Uniforms.VECTOR4:\n                    gl.uniform4fv(uniform.gpuPosition, uniform.value);\n                    break;\n                case XEngine.Uniforms.MAT2X2:\n                    gl.uniformMatrix2fv(uniform.gpuPosition, false, uniform.value);\n                    break;\n                case XEngine.Uniforms.MAT3X3:\n                    gl.uniformMatrix3fv(uniform.gpuPosition, false, uniform.value);\n                    break;\n                case XEngine.Uniforms.MAT4X4:\n                    gl.uniformMatrix4fv(uniform.gpuPosition, false, uniform.value);\n                    break;\n                default:\n                    gl.uniform1f(uniform.gpuPosition, uniform.value);\n                    break;\n            }\n        }\n        updateUniforms(gl) {\n            for (const property in this.uniforms) {\n                if (this.uniforms.hasOwnProperty(property)) {\n                    this._setUniform(this.uniforms[property], gl);\n                    this.uniforms[property].prevVal = this.uniforms[property].value;\n                }\n            }\n            for (let property in this.baseUniforms) {\n                if (this.baseUniforms.hasOwnProperty(property)) {\n                    this._setUniform(this.baseUniforms[property], gl);\n                    this.baseUniforms[property].prevVal = this.baseUniforms[property].value;\n                }\n            }\n        }\n    }\n    XEngine.Shader = Shader;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    let ShaderLib;\n    (function (ShaderLib) {\n        class ShaderLibObject {\n        }\n        ShaderLib.ShaderLibObject = ShaderLibObject;\n        class Sprite extends ShaderLibObject {\n        }\n        Sprite.vertexShader = [\n            \"#version 300 es\",\n            \"#XBaseParams\",\n            \"void mainPass() {\",\n            \"}\",\n        ];\n        Sprite.fragmentShader = [\n            \"#version 300 es\",\n            \"precision mediump float;\",\n            \"uniform sampler2D texSampler;\",\n            \"#XBaseParams\",\n            \"void main(void) {\",\n            \"vec4 texCol = texture(texSampler, uv);\",\n            \"texCol.rgb *= texCol.w;\",\n            \"texCol.xyz *= vColor;\",\n            \"fragColor = texCol*alpha;\",\n            \"}\",\n        ];\n        ShaderLib.Sprite = Sprite;\n        class SimpleColor extends ShaderLibObject {\n        }\n        SimpleColor.vertexShader = [\n            \"#version 300 es\",\n            \"#XBaseParams\",\n            \"void mainPass() {\",\n            \"}\",\n        ];\n        SimpleColor.fragmentShader = [\n            \"#version 300 es\",\n            \"precision mediump float;\",\n            \"#XBaseParams\",\n            \"void main(void) {\",\n            \"fragColor = vec4(vColor, alpha) * alpha;\",\n            \"}\",\n        ];\n        ShaderLib.SimpleColor = SimpleColor;\n        class CircleColor extends ShaderLibObject {\n        }\n        CircleColor.vertexShader = [\n            \"#version 300 es\",\n            \"#XBaseParams\",\n            \"void mainPass() {\",\n            \"}\",\n        ];\n        CircleColor.fragmentShader = [\n            \"#version 300 es\",\n            \"precision mediump float;\",\n            \"#XBaseParams\",\n            \"void main(void) {\",\n            \"vec2 uvOffset = uv - 0.5;\",\n            \"float distance = length(uvOffset);\",\n            \"float res = smoothstep(distance,distance+0.04,0.5);\",\n            \"if(res < 0.1) discard;\",\n            \"fragColor = vec4(1.0, 1.0, 1.0, res) * res * alpha;\",\n            \"fragColor.xyz *= vColor;\",\n            \"}\",\n        ];\n        ShaderLib.CircleColor = CircleColor;\n    })(ShaderLib = XEngine.ShaderLib || (XEngine.ShaderLib = {}));\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class CircleColor extends XEngine.Shader {\n        constructor() {\n            super(XEngine.ShaderLib.CircleColor.vertexShader, XEngine.ShaderLib.CircleColor.fragmentShader);\n        }\n    }\n    CircleColor.shader = new CircleColor();\n    XEngine.CircleColor = CircleColor;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class SimpleColor extends XEngine.Shader {\n        constructor() {\n            super(XEngine.ShaderLib.SimpleColor.vertexShader, XEngine.ShaderLib.SimpleColor.fragmentShader);\n        }\n    }\n    SimpleColor.shader = new SimpleColor();\n    XEngine.SimpleColor = SimpleColor;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    class SpriteShader extends XEngine.Shader {\n        constructor() {\n            super(XEngine.ShaderLib.Sprite.vertexShader, XEngine.ShaderLib.Sprite.fragmentShader);\n        }\n        _setTexture(texture) {\n            this.texture = texture;\n        }\n        _beginRender(gl) {\n            XEngine.Shader.prototype._beginRender.call(this, gl);\n            gl.activeTexture(gl.TEXTURE0);\n            gl.bindTexture(gl.TEXTURE_2D, this.texture);\n        }\n    }\n    SpriteShader.shader = new SpriteShader();\n    XEngine.SpriteShader = SpriteShader;\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    let SpriteBatcher;\n    (function (SpriteBatcher) {\n        class Consts {\n        }\n        Consts.VERTEX_SIZE = 24;\n        Consts.INDEX_SIZE = 2;\n        Consts.VERTEX_COUNT = 4;\n        Consts.INDEX_COUNT = 6;\n        Consts.VERTEX_COMPONENT_COUNT = 6;\n        Consts.MAX_SPRITES = 2000;\n        SpriteBatcher.Consts = Consts;\n    })(SpriteBatcher = XEngine.SpriteBatcher || (XEngine.SpriteBatcher = {}));\n})(XEngine || (XEngine = {}));\nvar XEngine;\n(function (XEngine) {\n    let SpriteBatcher;\n    (function (SpriteBatcher) {\n        class SpriteBatch {\n            constructor(game, gl, renderer) {\n                this.gl = gl;\n                this.game = game;\n                this.renderer = renderer;\n                this.maxSprites = null;\n                this.shader = null;\n                this.vertexBufferObject = null;\n                this.indexBufferObject = null;\n                this.vertexDataBuffer = null;\n                this.indexDataBuffer = null;\n                this.elementCount = 0;\n                this.currentTexture2D = null;\n                this.currentSprite = null;\n                this.mask = null;\n                this.vertexCount = 0;\n                this.init(this.gl);\n            }\n            shouldFlush() {\n                if (this.isFull()) {\n                    return true;\n                }\n                return false;\n            }\n            isFull() {\n                return (this.vertexDataBuffer.getByteLength() >= this.vertexDataBuffer.getByteCapacity());\n            }\n            bind(shader) {\n                if (!shader) {\n                    this.shader.bind(this.gl);\n                    this.shader.baseUniforms.pMatrix.value = this.game.camera.pMatrix;\n                    this.shader._setTexture(this.currentTexture2D);\n                    this.shader.updateUniforms(this.gl);\n                }\n                else {\n                    shader.bind(this.gl);\n                    shader.baseUniforms.pMatrix.value = this.game.camera.pMatrix;\n                    shader._setTexture(this.currentTexture2D);\n                    shader.updateUniforms(this.gl);\n                }\n                this.gl.bindTexture(this.gl.TEXTURE_2D, this.currentTexture2D);\n                this.vertexBufferObject.bind();\n                this.indexBufferObject.bind();\n            }\n            flush(shader) {\n                let gl = this.gl;\n                if (this.mask) {\n                    this.mask.rendermask(gl);\n                }\n                let vertexDataBuffer = this.vertexDataBuffer;\n                if (this.elementCount === 0 && this.vertexCount === 0) {\n                    return;\n                }\n                this.bind(shader);\n                this.vertexBufferObject.updateResource(vertexDataBuffer.floatView, 0);\n                gl.drawElements(gl.TRIANGLES, this.elementCount, gl.UNSIGNED_SHORT, 0);\n                vertexDataBuffer.clear();\n                this.elementCount = 0;\n                this.vertexCount = 0;\n                if (this.mask) {\n                    this.mask.endRendermask(gl);\n                    this.mask = null;\n                }\n            }\n            addSprite(gameObject, shader) {\n                if (gameObject.mask !== this.mask || this.shader !== shader) {\n                    this.flush(this.shader);\n                    this.shader = shader;\n                }\n                if (gameObject.mask) {\n                    this.mask = gameObject.mask;\n                }\n                this.renderer.setRenderer(this, gameObject.sprite);\n                let floatBuffer = this.vertexDataBuffer.floatView;\n                let uintBuffer = this.vertexDataBuffer.uintView;\n                let index = this.vertexDataBuffer.allocate(24);\n                let pos = new XEngine.Vector(0, 0);\n                mat4.identity(gameObject.mvMatrix);\n                gameObject.getWorldMatrix(gameObject.mvMatrix);\n                pos = pos.multiplyMatrix(gameObject.mvMatrix);\n                floatBuffer[index++] = pos.x;\n                floatBuffer[index++] = pos.y;\n                floatBuffer[index++] = gameObject._uv[0];\n                floatBuffer[index++] = gameObject._uv[1];\n                uintBuffer[index++] = gameObject.color;\n                floatBuffer[index++] = gameObject.alpha;\n                pos.setTo(0, gameObject.height);\n                pos = pos.multiplyMatrix(gameObject.mvMatrix);\n                floatBuffer[index++] = pos.x;\n                floatBuffer[index++] = pos.y;\n                floatBuffer[index++] = gameObject._uv[2];\n                floatBuffer[index++] = gameObject._uv[3];\n                uintBuffer[index++] = gameObject.color;\n                floatBuffer[index++] = gameObject.alpha;\n                pos.setTo(gameObject.width, 0);\n                pos = pos.multiplyMatrix(gameObject.mvMatrix);\n                floatBuffer[index++] = pos.x;\n                floatBuffer[index++] = pos.y;\n                floatBuffer[index++] = gameObject._uv[4];\n                floatBuffer[index++] = gameObject._uv[5];\n                uintBuffer[index++] = gameObject.color;\n                floatBuffer[index++] = gameObject.alpha;\n                pos.setTo(gameObject.width, gameObject.height);\n                pos = pos.multiplyMatrix(gameObject.mvMatrix);\n                floatBuffer[index++] = pos.x;\n                floatBuffer[index++] = pos.y;\n                floatBuffer[index++] = gameObject._uv[6];\n                floatBuffer[index++] = gameObject._uv[7];\n                uintBuffer[index++] = gameObject.color;\n                floatBuffer[index++] = gameObject.alpha;\n                this.currentTexture2D = this.game.cache.image(gameObject.sprite)._texture;\n                this.currentSprite = gameObject.sprite;\n                this.elementCount += 6;\n            }\n            init(gl) {\n                let vertexDataBuffer = new XEngine.DataBuffer32(SpriteBatcher.Consts.VERTEX_SIZE * SpriteBatcher.Consts.VERTEX_COUNT * SpriteBatcher.Consts.MAX_SPRITES);\n                let indexDataBuffer = new XEngine.DataBuffer16(SpriteBatcher.Consts.INDEX_SIZE * SpriteBatcher.Consts.INDEX_COUNT * SpriteBatcher.Consts.MAX_SPRITES);\n                let indexBufferObject = this.renderer.resourceManager.createBuffer(gl.ELEMENT_ARRAY_BUFFER, indexDataBuffer.getByteCapacity(), gl.STATIC_DRAW);\n                let vertexBufferObject = this.renderer.resourceManager.createBuffer(gl.ARRAY_BUFFER, vertexDataBuffer.getByteCapacity(), gl.STREAM_DRAW);\n                let shader = this.renderer.resourceManager.createShader(XEngine.SpriteShader);\n                let indexBuffer = indexDataBuffer.uintView;\n                let max = SpriteBatcher.Consts.MAX_SPRITES * SpriteBatcher.Consts.INDEX_COUNT;\n                this.vertexDataBuffer = vertexDataBuffer;\n                this.vertexBufferObject = vertexBufferObject;\n                this.indexDataBuffer = indexDataBuffer;\n                this.indexBufferObject = indexBufferObject;\n                this.shader = shader;\n                vertexBufferObject.addAttribute(shader.getAttribLocation(gl, \"aVertexPosition\"), 2, gl.FLOAT, false, SpriteBatcher.Consts.VERTEX_SIZE, 0);\n                vertexBufferObject.addAttribute(shader.getAttribLocation(gl, \"vUv\"), 2, gl.FLOAT, false, SpriteBatcher.Consts.VERTEX_SIZE, 8);\n                vertexBufferObject.addAttribute(shader.getAttribLocation(gl, \"aVertexColor\"), 3, gl.UNSIGNED_BYTE, true, SpriteBatcher.Consts.VERTEX_SIZE, 16);\n                vertexBufferObject.addAttribute(shader.getAttribLocation(gl, \"in_alpha\"), 1, gl.FLOAT, false, SpriteBatcher.Consts.VERTEX_SIZE, 20);\n                for (let indexA = 0, indexB = 0; indexA < max; indexA += SpriteBatcher.Consts.INDEX_COUNT, indexB += SpriteBatcher.Consts.VERTEX_COUNT) {\n                    indexBuffer[indexA + 0] = indexB + 0;\n                    indexBuffer[indexA + 1] = indexB + 1;\n                    indexBuffer[indexA + 2] = indexB + 2;\n                    indexBuffer[indexA + 3] = indexB + 1;\n                    indexBuffer[indexA + 4] = indexB + 3;\n                    indexBuffer[indexA + 5] = indexB + 2;\n                }\n                indexBufferObject.updateResource(indexBuffer, 0);\n            }\n        }\n        SpriteBatcher.SpriteBatch = SpriteBatch;\n    })(SpriteBatcher = XEngine.SpriteBatcher || (XEngine.SpriteBatcher = {}));\n})(XEngine || (XEngine = {}));\n"]}